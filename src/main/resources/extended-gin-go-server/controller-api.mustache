{{>partial_header}}
package {{packageName}}

{{#operations}}
import (
	"net/http"

	"github.com/gin-gonic/gin"
){{#operation}}

// {{nickname}} - {{{summary}}}
func {{nickname}}(c *gin.Context) {
	c.JSON(http.StatusOK, gin.H{})
}
{{/operation}}
{{/operations}}

{{! }}

{{! ITERATE FOR EACH OPERATION }}
{{#operations}}
    {{#operation}}
{{! FUNCTION PROTOTYPE }}
// {{nickname}} - {{{summary}}}
func {{nickname}}(c *gin.Context){
{{! VALIDATE PARAMETERS }}
        {{#allParams}}
            {{#isPathParam}}
                {{#isLong}}
    {{paramName}}, err := parseInt64Parameter(c.Param("{{paramName}}"))
    if err != nil {
        c.JSON(http.StatusBadRequest, gin.H{"error": err.Error()})
        return
    }
                {{/isLong}}
                {{#isInteger}}
    {{paramName}}, err := parseInt32Parameter(c.Param("{{paramName}}"))
    if err != nil {
        c.JSON(http.StatusBadRequest, gin.H{"error": err.Error()})
        return
    }
                {{/isInteger}}
                {{^isLong}}{{^isInteger}}
    {{paramName}} := c.Query({{paramName}})
                {{/isInteger}}{{/isLong}}
                {{/isPathParam}}
{{! QUERY PARAM PARSING WITH GIN:  c.QueryMap("paramName") }}
                {{#isQueryParam}}
                    {{#isLong}}
    {{paramName}}, err := parseInt64Parameter(c.Param("{{paramName}}"))
    if err != nil {
        c.JSON(http.StatusBadRequest, gin.H{"error": err.Error()})
        return
    }
                    {{/isLong}}
                    {{#isInteger}}
    {{paramName}}, err := parseInt32Parameter(c.Param("{{paramName}}"))
    if err != nil {
        c.JSON(http.StatusBadRequest, gin.H{"error": err.Error()})
        return
    }
                    {{/isInteger}}
                    {{^isLong}}{{^isInteger}}
    {{paramName}} := {{#isArray}}strings.Split({{/isArray}}c.Param("{{paramName}}"){{#isArray}}, ","){{/isArray}}
                    {{/isInteger}}{{/isLong}}
                {{/isQueryParam}}
                {{#isFormParam}}
                    {{#isFile}}
    {{paramName}}, err := ReadFormFileToTempFile(r, "{{paramName}}")
    if err != nil {
        c.JSON(http.StatusBadRequest, gin.H{"error": err.Error()})
        return
    }
                    {{/isFile}}
                    {{#isLong}}
    {{paramName}}, err := parseInt64Parameter( r.FormValue("{{paramName}}"))
    if err != nil {
        c.JSON(http.StatusBadRequest, gin.H{"error": err.Error()})
        return
    }
                    {{/isLong}}
                    {{#isInteger}}
    {{paramName}}, err := parseInt32Parameter( r.FormValue("{{paramName}}"))
    if err != nil {
        c.JSON(http.StatusBadRequest, gin.H{"error": err.Error()})
        return
    }
                    {{/isInteger}}
                    {{^isFile}}{{^isLong}}
    {{paramName}} := r.FormValue("{{paramName}}")
                    {{/isLong}}{{/isFile}}
                {{/isFormParam}}
                {{#isHeaderParam}}
    {{paramName}} := r.Header.Get("{{paramName}}")
                {{/isHeaderParam}}
                {{#isBodyParam}}
    {{paramName}} := &{{dataType}}{}
    if err := c.ShouldBind(&{{paramName}}); err != nil {
        c.String(http.StatusInternalServerError, "unknown error")
        return
    }
    //TODO: implement the func to generate in impl
                {{/isBodyParam}}
        {{/allParams}}
    result, err := c.service.{{nickname}}(r.Context(){{#allParams}}, {{#isBodyParam}}*{{/isBodyParam}}{{paramName}}{{/allParams}})
    //If an error occured, encode the error with the status code
    if err != nil {
    EncodeJSONResponse(err.Error(), &result.Code, w)
    return
    }
    //If no error, encode the body and the result code
    EncodeJSONResponse(result.Body, &result.Code, w)

}
    {{/operation}}
{{/operations}}
